import pandas as pd
import numpy as np
from datetime import datetime
import os

# =========================================================================
# === CONFIGURATION AND PATHS (EDIT AS NEEDED) ===
# =========================================================================
RAW_FILE_PATH = r"C:\Users\23480\Downloads\2024-12-16 (1).csv"
OUTPUT_DIR = r"C:\Users\23480\Desktop\streamlit_dashboard\house 1"

os.makedirs(OUTPUT_DIR, exist_ok=True)

raw_filename = os.path.basename(RAW_FILE_PATH)
base_name, ext = os.path.splitext(raw_filename)
OUTPUT_FILENAME = f"{base_name}_CLEANED{ext}"
OUTPUT_PATH = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME)

if os.path.exists(OUTPUT_PATH):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    OUTPUT_FILENAME = f"{base_name}_CLEANED_{timestamp}{ext}"
    OUTPUT_PATH = os.path.join(OUTPUT_DIR, OUTPUT_FILENAME)

print("="*80)
print("AUTO CSV CLEANER - STARTING")
print("="*80)
print(f"Input file: {RAW_FILE_PATH}")
print(f"Output file: {OUTPUT_PATH}")
print()

# =========================================================================
# === STEP 1: READ CSV (robust to extra trailing delimiter) ===
# =========================================================================
try:
    # Read with header row (assumes first row contains column names)
    df = pd.read_csv(
        RAW_FILE_PATH,
        sep=';',
        engine='python',
        encoding='utf-8',
        dtype=str,
        keep_default_na=False
    )
    print(f"✅ File read successfully. Detected columns: {len(df.columns)}")
except Exception as e:
    print(f"❌ Error reading file: {e}")
    raise

# If there's an extra empty trailing column (common with trailing semicolon), drop any columns that are entirely empty strings
empty_cols = [c for c in df.columns if df[c].replace('', np.nan).isna().all()]
if empty_cols:
    print(f"⚠️ Dropping entirely-empty columns (likely trailing delimiters): {empty_cols}")
    df = df.drop(columns=empty_cols)

print("\nSample of detected columns (first 10):")
print(df.columns.tolist()[:10])
print("\nRaw data sample (first 3 rows):")
print(df.head(3).to_string())

# =========================================================================
# === STEP 2: CLEAN TEXT FORMATTING (remove quotes, trailing 's', commas -> dots)
# =========================================================================
print("\n" + "="*80)
print("CLEANING DATA VALUES:")
print("="*80)

# Apply column-wise string cleaning (fast and avoids deprecated functions)
def clean_series(s: pd.Series) -> pd.Series:
    s = s.astype(str).str.strip()
    s = s.str.replace('"', '', regex=False)
    s = s.str.replace('s', '', regex=False)
    s = s.str.replace(',', '.', regex=False)
    return s

df = df.apply(clean_series)
print("✅ Removed quotes, 's' characters, and replaced commas with dots")

# =========================================================================
# === STEP 3: CREATE TIMESTAMP COLUMN (if Fecha & Hora exist) ===
# =========================================================================
print("\n" + "="*80)
print("HANDLING SPECIAL COLUMNS:")
print("="*80)

if 'Fecha' in df.columns and 'Hora' in df.columns:
    # Insert Timestamp at position after Fecha and Hora (we will move it later to after Row_Index)
    df.insert(len(df.columns), 'Timestamp', df['Fecha'].astype(str) + ' ' + df['Hora'].astype(str))
    df['Timestamp'] = pd.to_datetime(df['Timestamp'], format='%Y-%m-%d %H:%M:%S', errors='coerce')
    print("✅ New 'Timestamp' column created and converted to Datetime (NaT for unparsable rows).")
else:
    print("⚠️ 'Fecha' or 'Hora' column not found. Skipping Timestamp creation.")

# =========================================================================
# === STEP 4: FRACTION CONVERSION (e.g., '4/5' -> 0.8) — no applymap usage ===
# =========================================================================
def convert_fraction(value):
    # Only attempt for strings that look like fractions
    if isinstance(value, str) and '/' in value:
        parts = value.split('/')
        if len(parts) == 2:
            try:
                return float(parts[0]) / float(parts[1])
            except Exception:
                return value
    return value

# Apply per-column mapping (avoids deprecated applymap)
df = df.apply(lambda col: col.map(convert_fraction))
print("✅ Fraction conversion applied (e.g., '4/5' -> 0.8).")

# =========================================================================
# === STEP 5: CONVERT DATA TYPES ===
# =========================================================================
print("\n" + "="*80)
print("CONVERTING DATA TYPES:")
print("="*80)

# Convert all non-date/time columns to numeric (coerce errors -> NaN)
for col in df.columns:
    if col in ['Fecha', 'Hora', 'Timestamp']:
        continue
    # Use to_numeric with errors='coerce' — safe and explicit: non-convertible become NaN
    df[col] = pd.to_numeric(df[col], errors='coerce')

print("✅ All remaining columns converted to numeric (float) where possible.")

# =========================================================================
# === STEP 6: ADD ROW INDEX COLUMN (For Power BI) ===
# =========================================================================
# Insert the Row_Index column as the first column
df.insert(0, 'Row_Index', range(1, len(df) + 1))
print("\n✅ New column 'Row_Index' added successfully.")

# =========================================================================
# === STEP 7: VERIFY/REORDER FINAL COLUMN ORDER ===
# =========================================================================
print("\n" + "="*80)
print("VERIFYING FINAL COLUMN ORDER:")
print("="*80)

# Keep relative order of existing columns, but ensure Row_Index then Timestamp appear first
current_cols = df.columns.tolist()
# Build reordered list: Row_Index, Timestamp (if exists), then all other columns in their current order
reordered_cols = ['Row_Index']
if 'Timestamp' in current_cols:
    reordered_cols.append('Timestamp')
reordered_cols += [c for c in current_cols if c not in reordered_cols]
df = df[reordered_cols]

print(f"✅ Columns reordered. First columns: {df.columns[:5].tolist()}")

# =========================================================================
# === STEP 8: SAVE FINAL CLEAN CSV ===
# =========================================================================
print("\n" + "="*80)
print("FINAL DATA VERIFICATION AND SAVE:")
print("="*80)

print(f"✅ Final shape: {df.shape}")

# Save the file to the specified output path
df.to_csv(OUTPUT_PATH, index=False, encoding='utf-8')

print("\n" + "="*80)
print("✅ PROCESS COMPLETE!")
print("="*80)
print(f"Cleaned and indexed dataset successfully saved at:")
print(f"'{OUTPUT_PATH}'")
print("\n**The script handles any column count, drops only entirely-empty trailing columns, creates Timestamp if possible, converts fractions and numeric values, and adds Row_Index.**")
print("="*80)
